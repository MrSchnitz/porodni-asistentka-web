# ============================================
# Deploy to Raspberry Pi
# ============================================
#
# Build ARM64 image, deploy to RPi over Tailscale SSH. Migrations run at app startup (prodMigrations).
#
# ============================================
# REQUIRED SECRETS (GitHub → Settings → Secrets)
# ============================================
# Tailscale:
#   TAILSCALE_AUTHKEY   - Reusable auth key with tag:ci (create in Tailscale Admin → Keys)
#
# RPi / SSH:
#   TAILSCALE_PI_HOST    - RPi Tailscale hostname or IP (e.g. rpi-name or 100.x.x.x)
#   SERVER_PI_USER       - SSH user (e.g. pi)
#   SSH_PI_PRIVATE_KEY   - SSH private key (add public key to RPi ~/.ssh/authorized_keys)
#
# Migrations run at app startup via Payload prodMigrations (https://payloadcms.com/docs/database/migrations).
# RPi: Install Tailscale, SSH enabled, SERVER_PATH with docker compose (app + postgres).
#

name: Deploy to RPi

on:
  push:
    tags:
      - 'v*' # only run for tags like v1.0.0
  workflow_dispatch:

env:
  IMAGE_NAME: porodni-asistentka-web
  SERVER_PATH: ${{ secrets.SERVER_PATH }}

jobs:
  # ============================================
  # Job 1: Build Docker image for ARM64
  # ============================================
  build:
    name: Build ARM64 Image
    runs-on: ubuntu-latest
    outputs:
      image_version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU (for ARM64 build)
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate version
        id: version
        run: |
          VERSION="v${{ github.run_number }}-${GITHUB_SHA::7}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Build Docker image (ARM64)
        run: |
          docker buildx build \
            --platform linux/arm64 \
            --tag ${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }} \
            --tag ${{ env.IMAGE_NAME }}:latest \
            --output type=docker,dest=image.tar \
            .

      - name: Compress image
        run: |
          gzip image.tar
          ls -lh image.tar.gz
          echo "Image size: $(du -h image.tar.gz | cut -f1)"

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: image.tar.gz
          retention-days: 1

  # ============================================
  # Job 2: Deploy via Tailscale SSH + optional migrations
  # ============================================
  deploy:
    name: Deploy to RPi via Tailscale
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          authkey: ${{ secrets.TAILSCALE_AUTHKEY }}
          tags: tag:ci
          ping: ${{ secrets.TAILSCALE_PI_HOST }}

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PI_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.TAILSCALE_PI_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          cat >> ~/.ssh/config << EOF
          Host ${{ secrets.TAILSCALE_PI_HOST }}
              User ${{ secrets.SERVER_PI_USER }}
              IdentityFile ~/.ssh/deploy_key
              StrictHostKeyChecking accept-new
          EOF
          chmod 600 ~/.ssh/config

      - name: Copy image to server
        run: |
          echo "Copying image to server via Tailscale..."
          scp image.tar.gz ${{ secrets.SERVER_PI_USER }}@${{ secrets.TAILSCALE_PI_HOST }}:${{ env.SERVER_PATH }}/

      - name: Deploy on server
        run: |
          ssh ${{ secrets.SERVER_PI_USER }}@${{ secrets.TAILSCALE_PI_HOST }} << EOF
          set -e
          cd ${{ env.SERVER_PATH }}
          echo "Loading Docker image..."
          docker load < image.tar.gz
          echo "Restarting application..."
          docker compose down app || true
          docker compose up -d
          echo "Cleanup..."
          rm -f image.tar.gz
          docker image prune -f
          echo "Deployment complete!"
          docker compose ps
          EOF
